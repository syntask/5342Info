<!DOCTYPE html>
<html lang="en">

<head>
  <title>Potomac River Middair Collision Info</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="initial-scale=1,width=device-width,viewport-fit=cover" />
  <!-- PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/loaders/GLTFLoader.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/loaders/STLLoader.js'></script>
  <!-- Import MapTiler Geocoding Control -->
  <script src="https://unpkg.com/@maptiler/geocoding-control@latest/maplibregl.umd.js"></script>
  <link href="https://unpkg.com/@maptiler/geocoding-control@latest/style.css" rel="stylesheet" />
  <!-- Import turf.js from unpkg-->
  <script src="https://unpkg.com/@turf/turf@latest"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      transform: scale(1);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      height: 100svh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background-color: #222;
    }

    /* Adjust the map height to allow room for the audio controls */
    #map {
      height: 100px;
      width: 100vw;
      flex-grow: 1;
    }

    /* --- Custom Audio Controls --- */
    #audio-controls {
      background-color: #222;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 10px;
      width: 1000px;
      max-width: 100vw;
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* Updated play/pause button */
    #audio-controls button#play-pause {
      width: 40px;
      height: 40px;
      padding: 0;
      border: none;
      background-color: #444;
      cursor: pointer;
      margin-right: 10px;
      border-radius: 999px;
    }

    /* The inner container for centering the SVGs */
    #audio-controls button#play-pause>div {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Center the SVG icons inside the button */
    #audio-controls button#play-pause>div svg {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 18px;
      height: 18px;
      transform: translate(-50%, -50%);
      transition: opacity 0.2s, transform 0.2s;
    }

    /* When button has .paused: show play icon at full size, hide pause icon */
    #audio-controls button#play-pause.paused #play-icon {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    #audio-controls button#play-pause.paused #pause-icon {
      transform: translate(-50%, -50%) scale(0.5);
      opacity: 0;
    }

    /* When not paused: show pause icon at full size, hide play icon */
    #audio-controls button#play-pause:not(.paused) #play-icon {
      transform: translate(-50%, -50%) scale(0.5);
      opacity: 0;
    }

    #audio-controls button#play-pause:not(.paused) #pause-icon {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    /* --- Range Slider and other controls --- */
    #audio-controls input[type="range"] {
      width: 300px;
      flex-grow: 1;
      margin: 0 10px;
      cursor: grab;
    }

    #audio-controls input[type="range"]:active {
      cursor: grabbing;
    }


    #current-time,
    #duration {
      width: 40px;
      text-align: center;
    }

    /* --- Marker CSS --- */
    .flight-marker-container {
      width: 16px;
      height: 16px;
    }

    .flight-marker-icon {
      width: 16px;
      height: 16px;
      background-size: contain;
      background-repeat: no-repeat;
    }

    .flight-marker-label {
      font-family: sans-serif;
      font-size: 10px;
      color: #ffffff;
      white-space: nowrap;
      transform-origin: top left;
      background-color: #00000044;
      backdrop-filter: blur(10px);
      padding: 2px 4px;
      border-radius: 4px;
    }

    /* --- Custom Visibility Control CSS --- */
    .custom-visibility-control {
      background: #222;
      color: #fff;
      padding: 8px 8px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .maplibregl-ctrl-group {
      background-color: #222;
    }

    .maplibregl-ctrl-group button span {
      filter: invert(1);
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <!-- Audio element without default controls -->
  <audio id="audioPlayer" src="assets/atc-audio.mp3" preload="auto"></audio>

  <!-- Custom audio controls -->
  <div id="audio-controls">
    <button id="play-pause" class="paused">
      <div>
        <!-- Play Icon SVG -->
        <svg id="play-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7472 16.0467">
          <g>
            <rect height="16.0467" opacity="0" width="15.7472" x="0" y="0" />
            <path
              d="M1.63027 14.7928C1.63027 15.6476 2.13545 16.0339 2.71172 16.0339C2.96533 16.0339 3.22871 15.9544 3.47998 15.8193L14.8569 9.10537C15.504 8.73047 15.7472 8.45362 15.7472 8.01846C15.7472 7.57354 15.504 7.30342 14.8569 6.93154L3.47998 0.214551C3.22871 0.0757813 2.96533 0 2.71172 0C2.13545 0 1.63027 0.389356 1.63027 1.24414Z"
              fill="white" fill-opacity="0.85" />
          </g>
        </svg>
        <!-- Pause Icon SVG -->
        <svg id="pause-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.6064 15.7928">
          <g>
            <rect height="15.7928" opacity="0" width="11.6064" x="0" y="0" />
            <path
              d="M1.15352 15.78L3.31953 15.78C4.09043 15.78 4.47305 15.4004 4.47305 14.6197L4.47305 1.15352C4.47305 0.348926 4.09043 0 3.31953 0L1.15352 0C0.382618 0 0 0.375879 0 1.15352L0 14.6197C0 15.4004 0.382618 15.78 1.15352 15.78ZM7.93526 15.78L10.0915 15.78C10.8722 15.78 11.245 15.4004 11.245 14.6197L11.245 1.15352C11.245 0.348926 10.8722 0 10.0915 0L7.93526 0C7.15459 0 6.77198 0.375879 6.77198 1.15352L6.77198 14.6197C6.77198 15.4004 7.15459 15.78 7.93526 15.78Z"
              fill="white" fill-opacity="0.85" />
          </g>
        </svg>
      </div>
    </button>
    <span id="current-time">0:00</span>
    <input type="range" id="seek-slider" min="0" max="100" value="0" step="0.1">
    <span id="duration">0:00</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "turf": "https://unpkg.com/@turf/turf@latest"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    // === Custom Audio Controls Setup ===
    const audioPlayer = document.getElementById('audioPlayer');
    const playPauseButton = document.getElementById('play-pause');
    const seekSlider = document.getElementById('seek-slider');
    const currentTimeSpan = document.getElementById('current-time');
    const durationSpan = document.getElementById('duration');

    // When metadata is loaded, update the duration display and slider max.
    audioPlayer.addEventListener('loadedmetadata', () => {
      seekSlider.max = audioPlayer.duration;
      durationSpan.textContent = formatTime(audioPlayer.duration);
    });

    // Update the slider and current time display as the audio plays.
    audioPlayer.addEventListener('timeupdate', () => {
      seekSlider.value = audioPlayer.currentTime;
      currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);
    });

    // Allow seeking via the slider.
    seekSlider.addEventListener('input', () => {
      audioPlayer.currentTime = seekSlider.value;
    });

    // Toggle play/pause and update button class.
    playPauseButton.addEventListener('click', () => {
      if (audioPlayer.paused) {
        audioPlayer.play();
        playPauseButton.classList.remove('paused');
      } else {
        audioPlayer.pause();
        playPauseButton.classList.add('paused');
      }
    });

    function formatTime(time) {
      const minutes = Math.floor(time / 60);
      const seconds = Math.floor(time % 60);
      return minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
    }

    // === Flight Simulation Code (unchanged) ===
    const flightsData = {};
    var flightFollowing = null;

    // Define the audio time segment (simulation time offset)
    const audioStart = 1738201610; // simulation time corresponding to audio time 0
    const audioEnd = 1738201717;

    // Initialize MapLibre map.
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://api.maptiler.com/maps/d856b495-1396-447c-80d5-0fd7fca006e0/style.json?key=uxGPO18AyvxUdEGKe02K',
      zoom: 12,
      center: [-77.024841, 38.84221],
      pitch: 0,
      maxPitch: 88,
      canvasContextAttributes: { antialias: true }
    });

    // Collapse the attribution control on load
    document.querySelector('.maplibregl-ctrl-attrib').classList.remove('maplibregl-compact-show');

    function bearingBetweenCoords([lng1, lat1], [lng2, lat2]) {
      const toRad = deg => deg * Math.PI / 180;
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const λ1 = toRad(lng1), λ2 = toRad(lng2);
      const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }

    /**
     * Interpolates flight track position given a track array and timestamp.
     */
    function getInterpolatedTrack(trackArray, timestamp) {
      if (!trackArray || !trackArray.length) return null;
      if (timestamp <= trackArray[0].timestamp) {
        const heading = bearingBetweenCoords(trackArray[0].coord, trackArray[1].coord);
        return { ...trackArray[0], timestamp, heading };
      }
      if (timestamp >= trackArray[trackArray.length - 1].timestamp) {
        const n = trackArray.length;
        const heading = bearingBetweenCoords(trackArray[n - 2].coord, trackArray[n - 1].coord);
        return { ...trackArray[n - 1], timestamp, heading };
      }
      const exact = trackArray.find(t => t.timestamp === timestamp);
      if (exact) {
        const index = trackArray.indexOf(exact);
        let heading = 0;
        if (index > 0 && index < trackArray.length - 1) {
          heading = bearingBetweenCoords(trackArray[index - 1].coord, trackArray[index].coord);
        }
        return { ...exact, heading };
      }
      let i = 0;
      while (i < trackArray.length - 1 && trackArray[i + 1].timestamp < timestamp) i++;
      const prev = trackArray[i], next = trackArray[i + 1];
      const dt = next.timestamp - prev.timestamp;
      const ratio = (timestamp - prev.timestamp) / dt;
      const [lng1, lat1] = prev.coord;
      const [lng2, lat2] = next.coord;
      const lng = lng1 + ratio * (lng2 - lng1);
      const lat = lat1 + ratio * (lat2 - lat1);
      let alt;
      if (prev.alt != null && next.alt != null) {
        alt = prev.alt + ratio * (next.alt - prev.alt);
      }
      const heading = bearingBetweenCoords(prev.coord, next.coord);
      return { timestamp, coord: [lng, lat], alt, heading };
    }

    function parseGeojsonToTrack(geojson) {
      if (!geojson.features || !geojson.features.length) {
        console.warn("No features found in GeoJSON");
        return [];
      }
      const feature = geojson.features[0];
      if (!feature.properties || !feature.properties.timestamps) {
        console.warn("No timestamps found in feature properties.");
        return [];
      }
      const coords = feature.geometry.coordinates;
      const timestamps = feature.properties.timestamps;
      if (coords.length !== timestamps.length) {
        console.warn("Coordinates and timestamps mismatch!");
      }
      const trackArray = coords.map((pt, i) => {
        const [lng, lat, alt = 0] = pt;
        return { timestamp: timestamps[i], coord: [lng, lat], alt };
      });
      trackArray.sort((a, b) => a.timestamp - b.timestamp);
      return trackArray;
    }

    /**
     * Generates a data URL for an inline SVG flight marker.
     */
    function createFlightMarkerSVG(color) {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30">
        <polygon points="15,0 30,30 15,25 0,30" fill="${color}" />
      </svg>`;
      return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
    }

    // Update both the 3D model and the 2D markers based on simulation time.
    function updateFlightPositions(simulationTime) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        const trackArray = flightObj.track;
        if (!trackArray || !trackArray.length) continue;
        const interpolated = getInterpolatedTrack(trackArray, simulationTime);
        if (!interpolated) {
          console.log(`Flight ${flightId} has no valid interpolation at time ${simulationTime}.`);
          continue;
        }
        // Update 3D model transformation.
        if (flightObj.modelTransform) {
          if (flightFollowing === flightId) {
            const lookbeyond = interpolated.alt * 5.67;
            const bearing = interpolated.heading;
            const pitch = 80;
            const zoom = 22.4 - Math.log2(interpolated.alt);
            const lookAheadPoint = turf.destination(
              turf.point(interpolated.coord),
              lookbeyond,
              bearing,
              { units: 'meters' }
            );
            map.jumpTo({
              center: lookAheadPoint.geometry.coordinates,
              bearing: bearing,
              pitch: pitch,
              zoom: zoom
            });
          }
          const headingDeg = interpolated.heading || 0;
          const headingRad = (180 - headingDeg) * Math.PI / 180;
          const merc = maplibregl.MercatorCoordinate.fromLngLat(
            interpolated.coord,
            interpolated.alt
          );
          const scale = merc.meterInMercatorCoordinateUnits() * flightObj.scale * 100;
          flightObj.modelTransform.translateX = merc.x;
          flightObj.modelTransform.translateY = merc.y;
          flightObj.modelTransform.translateZ = merc.z;
          flightObj.modelTransform.rotateX = Math.PI / 2;
          flightObj.modelTransform.rotateY = headingRad;
          flightObj.modelTransform.rotateZ = 0;
          flightObj.modelTransform.scale = scale;
        }
        // Update the icon marker position and rotation.
        if (flightObj.iconMarker) {
          flightObj.iconMarker.setLngLat(interpolated.coord);
          flightObj.iconElement.style.transform = `rotate(${interpolated.heading}deg)`;
        }
        // Update the label marker position and text.
        if (flightObj.labelMarker) {
          flightObj.labelMarker.setLngLat(interpolated.coord);
          flightObj.labelMarker.getElement().innerText =
            `${flightObj.flightName} / ${flightObj.tail} @ ${Math.round(interpolated.alt * 3.28)} ft`;
        }
      }
      map.triggerRepaint();
    }

    // Instead of using the original 'atcAudio', we now use our custom-controlled audioPlayer.
    audioPlayer.addEventListener('timeupdate', () => {
      const simTime = audioPlayer.currentTime + audioStart;
      updateFlightPositions(simTime);
    });

    function animate() {
      requestAnimationFrame(animate);
      if (!audioPlayer.paused) {
        const simTime = audioPlayer.currentTime + audioStart;
        updateFlightPositions(simTime);
      }
    }
    animate();

    // ----- Flight Rendering Code for 3D Models -----
    function addStlModel(flightId, modelUrl, color) {
      const customLayer = {
        id: flightsData[flightId].layerId,
        type: 'custom',
        renderingMode: '3d',
        onAdd(map, gl) {
          this.map = map;
          this.flightId = flightId;
          this.camera = new THREE.Camera();
          this.scene = new THREE.Scene();
          const ambientLight = new THREE.AmbientLight(0xffffff);
          this.scene.add(ambientLight);
          const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 2);
          this.scene.add(hemisphereLight);
          const loader = new STLLoader();
          loader.load(
            modelUrl,
            stl => {
              const material = new THREE.MeshPhongMaterial({
                color: color,
                specular: 0x111111,
                shininess: 0
              });
              const mesh = new THREE.Mesh(stl, material);
              mesh.scale.set(1, 1, 1);
              mesh.rotation.x = -Math.PI / 2;
              this.scene.add(mesh);
            },
            undefined,
            err => {
              console.error("STL load error:", err);
            }
          );
          this.renderer = new THREE.WebGLRenderer({
            canvas: map.getCanvas(),
            context: gl,
            antialias: true
          });
          this.renderer.autoClear = false;
        },
        render(gl, matrix) {
          const flightObj = flightsData[this.flightId];
          const mt = flightObj.modelTransform;
          const rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), mt.rotateX);
          const rotationY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), mt.rotateY);
          const rotationZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), mt.rotateZ);
          const m = new THREE.Matrix4().fromArray(matrix.defaultProjectionData.mainMatrix);
          const l = new THREE.Matrix4()
            .makeTranslation(mt.translateX, mt.translateY, mt.translateZ)
            .scale(new THREE.Vector3(mt.scale, -mt.scale, mt.scale))
            .multiply(rotationX)
            .multiply(rotationY)
            .multiply(rotationZ);
          this.camera.projectionMatrix = m.multiply(l);
          this.renderer.resetState();
          this.renderer.render(this.scene, this.camera);
          this.map.triggerRepaint();
        }
      };
      map.addLayer(customLayer);
    }

    // ----- Custom Control for Visibility Toggling -----
    class VisibilityControl {
      onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'maplibregl-ctrl custom-visibility-control';
        this._container.innerHTML = `
          <div><input type="checkbox" id="toggle2d" checked> <label for="toggle2d">2D Aircraft</label></div>
          <div><input type="checkbox" id="toggle3d" checked> <label for="toggle3d">3D Aircraft</label></div>
          <div><input type="checkbox" id="toggleTracks" checked> <label for="toggleTracks">Track Logs</label></div>
        `;
        this._container.querySelector('#toggle2d').addEventListener('change', (e) => {
          toggle2d(e.target.checked);
        });
        this._container.querySelector('#toggle3d').addEventListener('change', (e) => {
          toggle3d(e.target.checked);
        });
        this._container.querySelector('#toggleTracks').addEventListener('change', (e) => {
          toggleTracks(e.target.checked);
        });
        return this._container;
      }
      onRemove() {
        this._container.parentNode.removeChild(this._container);
        this._map = undefined;
      }
    }

    function toggle2d(visible) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        if (flightObj.iconMarker) {
          flightObj.iconMarker.getElement().style.display = visible ? 'block' : 'none';
        }
        if (flightObj.labelMarker) {
          flightObj.labelMarker.getElement().style.display = visible ? 'block' : 'none';
        }
      }
    }

    function toggle3d(visible) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        if (flightObj.layerId) {
          map.setLayoutProperty(flightObj.layerId, 'visibility', visible ? 'visible' : 'none');
        }
      }
    }

    function toggleTracks(visible) {
      for (const flightId in flightsData) {
        map.setLayoutProperty(flightId + '-layer', 'visibility', visible ? 'visible' : 'none');
      }
    }

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new VisibilityControl(), 'top-right');

    map.on('load', () => {
      map.setSky({
        "sky-color": "#000000",
        "sky-horizon-blend": 0.5,
        "horizon-color": "#222222",
        "horizon-fog-blend": 0.5,
        "fog-color": "#444444",
        "fog-ground-blend": 0.5,
        "atmosphere-blend": [
          "interpolate",
          ["linear"],
          ["zoom"],
          0,
          1,
          10,
          1,
          12,
          0
        ]
      });

      function addFlight(id, dataUrl, color, modelUrl, modelScale) {
        map.addSource(id + '-source', { type: 'geojson', data: dataUrl });
        map.on('data', function (e) {
          if (e.sourceId === id + '-source' && e.sourceDataType === 'metadata') {
            // Add the track log.
            map.addLayer({
              id: id + '-layer',
              type: 'line',
              source: id + '-source',
              layout: { 'line-join': 'round', 'line-cap': 'round' },
              paint: { 'line-color': color, 'line-width': 2 }
            });
            fetch(dataUrl)
              .then(response => response.json())
              .then(geojson => {
                const flightType = geojson.properties.type;
                const tail = geojson.properties.tail;
                const flightName = geojson.properties.flight;
                console.log(`Flight ${flightName} (${flightType}) with tail #${tail} loaded.`);
                const trackArray = parseGeojsonToTrack(geojson);
                const modelTransform = {
                  translateX: 0, translateY: 0, translateZ: 0,
                  rotateX: 0, rotateY: 0, rotateZ: 0,
                  scale: 1
                };
                flightsData[id] = {
                  track: trackArray,
                  color: color,
                  flightType: flightType,
                  flightName: flightName,
                  tail: tail,
                  modelTransform: modelTransform,
                  layerId: id + '-model',
                  scale: modelScale
                };
                const initialCoord = trackArray.length ? trackArray[0].coord : [0, 0];

                // Create the icon marker.
                const iconContainer = document.createElement('div');
                iconContainer.className = 'flight-marker-container';
                const iconElement = document.createElement('div');
                iconElement.className = 'flight-marker-icon';
                iconElement.style.backgroundImage = `url("${createFlightMarkerSVG(color)}")`;
                iconContainer.appendChild(iconElement);
                const iconMarker = new maplibregl.Marker({
                  element: iconContainer,
                  rotationAlignment: 'map'
                })
                  .setLngLat(initialCoord)
                  .addTo(map);
                flightsData[id].iconMarker = iconMarker;
                flightsData[id].iconElement = iconElement;

                // Create the label marker.
                const labelElement = document.createElement('div');
                labelElement.className = 'flight-marker-label';
                labelElement.innerText = `${flightName} / ${tail} @ 0 m`;
                const labelMarker = new maplibregl.Marker({
                  element: labelElement,
                  rotationAlignment: 'viewport',
                  anchor: 'top-left',
                  offset: [20, 0]
                })
                  .setLngLat(initialCoord)
                  .addTo(map);
                flightsData[id].labelMarker = labelMarker;
                flightsData[id].labelElement = labelElement;

                addStlModel(id, modelUrl, color);

                // Set initial flight locations
                updateFlightPositions(audioStart);
              });
          }
        });
      }

      // Add your flights.
      addFlight('AE313D', './assets/AE313D-track.geojson', '#ff453a', './assets/UH-60.stl', 1 / 1200);
      addFlight('N709PS', './assets/N709PS-track.geojson', '#0a84ff', './assets/CRJ7.stl', 1 / 300);
      addFlight('N765US', './assets/N765US-track.geojson', '#30d158', './assets/CRJ7.stl', 1 / 300);
      addFlight('N941NN', './assets/N941NN-track.geojson', '#bf5af2', './assets/CRJ7.stl', 1 / 300);
    });
  </script>
</body>

</html>