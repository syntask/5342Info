<!DOCTYPE html>
<html lang="en">
<head>
  <title>Potomac River Middair Collision Info</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="initial-scale=1,width=device-width,viewport-fit=cover" />
  <!-- PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/loaders/GLTFLoader.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/loaders/STLLoader.js'></script>
  <!-- Import MapTiler Geocoding Control -->
  <script src="https://unpkg.com/@maptiler/geocoding-control@latest/maplibregl.umd.js"></script>
  <link href="https://unpkg.com/@maptiler/geocoding-control@latest/style.css" rel="stylesheet" />
  <!-- Import turf.js from unpkg-->
  <script src="https://unpkg.com/@turf/turf@latest"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      transform: scale(1);
    }
    #map {
      height: calc(100vh - 80px);
      width: 100vw;
    }
    /* Optional: position the audio player at the bottom */
    #audioPlayer {
      width: 100%;
    }
    /* --- Marker CSS --- */
    /* Icon marker container (fixed size so its center aligns with the coordinate) */
    .flight-marker-container {
      width: 30px;
      height: 30px;
    }
    .flight-marker-icon {
      width: 30px;
      height: 30px;
      background-size: contain;
      background-repeat: no-repeat;
      /* The rotation transform is applied directly to the icon element */
    }
    /* Label marker styles – this element remains upright (viewport alignment) */
    .flight-marker-label {
      font-family: sans-serif;
      font-size: 10px;
      color: #ffffff;
      white-space: nowrap;
      transform-origin: top left;
      background-color: #00000044;
      backdrop-filter: blur(10px);
      padding: 2px 4px;
      border-radius: 4px;
    }
    /* Styles for the custom visibility control */
    .custom-visibility-control {
      background: white;
      padding: 10px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .custom-visibility-control div {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <!-- Audio element replaces slider and play button -->
  <audio id="audioPlayer" src="assets/atc-audio.mp3" preload="auto" controls></audio>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "turf": "https://unpkg.com/@turf/turf@latest"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    const flightsData = {};
    var flightFollowing = null;

    // --- Define the audio time segment ---
    const audioStart = 1738201610; // simulation time corresponding to audio time 0
    const audioEnd   = 1738201717;
    const atcAudio = document.getElementById('audioPlayer');

    // Initialize MapLibre map.
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://api.maptiler.com/maps/d856b495-1396-447c-80d5-0fd7fca006e0/style.json?key=uxGPO18AyvxUdEGKe02K',
      zoom: 16,
      center: [-77.02168887575309, 38.852339192876684],
      pitch: 60,
      maxPitch: 88,
      canvasContextAttributes: { antialias: true }
    });

    function bearingBetweenCoords([lng1, lat1], [lng2, lat2]) {
      const toRad = deg => deg * Math.PI / 180;
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const λ1 = toRad(lng1), λ2 = toRad(lng2);
      const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
                Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
      let brng = Math.atan2(y, x) * 180 / Math.PI;
      return (brng + 360) % 360;
    }

    /**
     * Interpolates flight track position given a track array and timestamp.
     */
    function getInterpolatedTrack(trackArray, timestamp) {
      if (!trackArray || !trackArray.length) return null;
      if (timestamp <= trackArray[0].timestamp) {
        const heading = bearingBetweenCoords(trackArray[0].coord, trackArray[1].coord);
        return { ...trackArray[0], timestamp, heading };
      }
      if (timestamp >= trackArray[trackArray.length - 1].timestamp) {
        const n = trackArray.length;
        const heading = bearingBetweenCoords(trackArray[n - 2].coord, trackArray[n - 1].coord);
        return { ...trackArray[n - 1], timestamp, heading };
      }
      const exact = trackArray.find(t => t.timestamp === timestamp);
      if (exact) {
        const index = trackArray.indexOf(exact);
        let heading = 0;
        if (index > 0 && index < trackArray.length - 1) {
          heading = bearingBetweenCoords(trackArray[index - 1].coord, trackArray[index].coord);
        }
        return { ...exact, heading };
      }
      let i = 0;
      while (i < trackArray.length - 1 && trackArray[i + 1].timestamp < timestamp) i++;
      const prev = trackArray[i], next = trackArray[i + 1];
      const dt = next.timestamp - prev.timestamp;
      const ratio = (timestamp - prev.timestamp) / dt;
      const [lng1, lat1] = prev.coord;
      const [lng2, lat2] = next.coord;
      const lng = lng1 + ratio * (lng2 - lng1);
      const lat = lat1 + ratio * (lat2 - lat1);
      let alt;
      if (prev.alt != null && next.alt != null) {
        alt = prev.alt + ratio * (next.alt - prev.alt);
      }
      const heading = bearingBetweenCoords(prev.coord, next.coord);
      return { timestamp, coord: [lng, lat], alt, heading };
    }

    function parseGeojsonToTrack(geojson) {
      if (!geojson.features || !geojson.features.length) {
        console.warn("No features found in GeoJSON");
        return [];
      }
      const feature = geojson.features[0];
      if (!feature.properties || !feature.properties.timestamps) {
        console.warn("No timestamps found in feature properties.");
        return [];
      }
      const coords = feature.geometry.coordinates;
      const timestamps = feature.properties.timestamps;
      if (coords.length !== timestamps.length) {
        console.warn("Coordinates and timestamps mismatch!");
      }
      const trackArray = coords.map((pt, i) => {
        const [lng, lat, alt = 0] = pt;
        return { timestamp: timestamps[i], coord: [lng, lat], alt };
      });
      trackArray.sort((a, b) => a.timestamp - b.timestamp);
      return trackArray;
    }

    /**
     * Generates a data URL for an inline SVG flight marker.
     */
    function createFlightMarkerSVG(color) {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30">
        <polygon points="15,0 30,30 15,25 0,30" fill="${color}" />
      </svg>`;
      return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
    }

    // Update both the 3D model and the 2D markers based on simulation time.
    function updateFlightPositions(simulationTime) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        const trackArray = flightObj.track;
        if (!trackArray || !trackArray.length) continue;
        const interpolated = getInterpolatedTrack(trackArray, simulationTime);
        if (!interpolated) {
          console.log(`Flight ${flightId} has no valid interpolation at time ${simulationTime}.`);
          continue;
        }
        // Update 3D model transformation.
        if (flightObj.modelTransform) {
          if (flightFollowing === flightId) {
            const lookbeyond = interpolated.alt * 5.67;
            const bearing = interpolated.heading;
            const pitch = 80;
            const zoom = 22.4 - Math.log2(interpolated.alt);
            const lookAheadPoint = turf.destination(
              turf.point(interpolated.coord),
              lookbeyond,
              bearing,
              { units: 'meters' }
            );
            map.jumpTo({
              center: lookAheadPoint.geometry.coordinates,
              bearing: bearing,
              pitch: pitch,
              zoom: zoom
            });
          }
          const headingDeg = interpolated.heading || 0;
          const headingRad = (180 - headingDeg) * Math.PI / 180;
          const merc = maplibregl.MercatorCoordinate.fromLngLat(
            interpolated.coord,
            interpolated.alt
          );
          const scale = merc.meterInMercatorCoordinateUnits() * flightObj.scale * 100;
          flightObj.modelTransform.translateX = merc.x;
          flightObj.modelTransform.translateY = merc.y;
          flightObj.modelTransform.translateZ = merc.z;
          flightObj.modelTransform.rotateX = Math.PI / 2;
          flightObj.modelTransform.rotateY = headingRad;
          flightObj.modelTransform.rotateZ = 0;
          flightObj.modelTransform.scale = scale;
        }
        // Update the icon marker position and rotation.
        if (flightObj.iconMarker) {
          flightObj.iconMarker.setLngLat(interpolated.coord);
          flightObj.iconElement.style.transform = `rotate(${interpolated.heading}deg)`;
        }
        // Update the label marker position and text.
        if (flightObj.labelMarker) {
          flightObj.labelMarker.setLngLat(interpolated.coord);
          flightObj.labelMarker.getElement().innerText =
            `${flightObj.flightName} / ${flightObj.tail} @ ${Math.round(interpolated.alt * 3.28)} ft`;
        }
      }
      map.triggerRepaint();
    }

    atcAudio.addEventListener('timeupdate', () => {
      const simTime = atcAudio.currentTime + audioStart;
      updateFlightPositions(simTime);
    });

    function animate() {
      requestAnimationFrame(animate);
      if (!atcAudio.paused) {
        const simTime = atcAudio.currentTime + audioStart;
        updateFlightPositions(simTime);
      }
    }
    animate();

    // ----- Flight Rendering Code for 3D Models -----
    function addStlModel(flightId, modelUrl, color) {
      const customLayer = {
        id: flightsData[flightId].layerId,
        type: 'custom',
        renderingMode: '3d',
        onAdd(map, gl) {
          this.map = map;
          this.flightId = flightId;
          this.camera = new THREE.Camera();
          this.scene = new THREE.Scene();
          const ambientLight = new THREE.AmbientLight(0xffffff);
          this.scene.add(ambientLight);
          const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 2);
          this.scene.add(hemisphereLight);
          const loader = new STLLoader();
          loader.load(
            modelUrl,
            stl => {
              const material = new THREE.MeshPhongMaterial({
                color: color,
                specular: 0x111111,
                shininess: 0
              });
              const mesh = new THREE.Mesh(stl, material);
              mesh.scale.set(1, 1, 1);
              mesh.rotation.x = -Math.PI / 2;
              this.scene.add(mesh);
            },
            undefined,
            err => {
              console.error("STL load error:", err);
            }
          );
          this.renderer = new THREE.WebGLRenderer({
            canvas: map.getCanvas(),
            context: gl,
            antialias: true
          });
          this.renderer.autoClear = false;
        },
        render(gl, matrix) {
          const flightObj = flightsData[this.flightId];
          const mt = flightObj.modelTransform;
          const rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), mt.rotateX);
          const rotationY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), mt.rotateY);
          const rotationZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), mt.rotateZ);
          const m = new THREE.Matrix4().fromArray(matrix.defaultProjectionData.mainMatrix);
          const l = new THREE.Matrix4()
            .makeTranslation(mt.translateX, mt.translateY, mt.translateZ)
            .scale(new THREE.Vector3(mt.scale, -mt.scale, mt.scale))
            .multiply(rotationX)
            .multiply(rotationY)
            .multiply(rotationZ);
          this.camera.projectionMatrix = m.multiply(l);
          this.renderer.resetState();
          this.renderer.render(this.scene, this.camera);
          this.map.triggerRepaint();
        }
      };
      map.addLayer(customLayer);
    }

    // ----- Custom Control for Visibility Toggling -----
    class VisibilityControl {
      onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'maplibregl-ctrl custom-visibility-control';
        this._container.innerHTML = `
          <div><input type="checkbox" id="toggle2d" checked> <label for="toggle2d">2D Aircraft</label></div>
          <div><input type="checkbox" id="toggle3d" checked> <label for="toggle3d">3D Aircraft</label></div>
          <div><input type="checkbox" id="toggleTracks" checked> <label for="toggleTracks">Track Logs</label></div>
        `;
        this._container.querySelector('#toggle2d').addEventListener('change', (e) => {
          toggle2d(e.target.checked);
        });
        this._container.querySelector('#toggle3d').addEventListener('change', (e) => {
          toggle3d(e.target.checked);
        });
        this._container.querySelector('#toggleTracks').addEventListener('change', (e) => {
          toggleTracks(e.target.checked);
        });
        return this._container;
      }
      onRemove() {
        this._container.parentNode.removeChild(this._container);
        this._map = undefined;
      }
    }

    function toggle2d(visible) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        if (flightObj.iconMarker) {
          flightObj.iconMarker.getElement().style.display = visible ? 'block' : 'none';
        }
        if (flightObj.labelMarker) {
          flightObj.labelMarker.getElement().style.display = visible ? 'block' : 'none';
        }
      }
    }

    function toggle3d(visible) {
      for (const flightId in flightsData) {
        const flightObj = flightsData[flightId];
        if (flightObj.layerId) {
          map.setLayoutProperty(flightObj.layerId, 'visibility', visible ? 'visible' : 'none');
        }
      }
    }

    function toggleTracks(visible) {
      for (const flightId in flightsData) {
        map.setLayoutProperty(flightId + '-layer', 'visibility', visible ? 'visible' : 'none');
      }
    }

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new VisibilityControl(), 'top-right');

    map.on('load', () => {
      map.setSky({
        "sky-color": "#000000",
        "sky-horizon-blend": 0.5,
        "horizon-color": "#222222",
        "horizon-fog-blend": 0.5,
        "fog-color": "#444444",
        "fog-ground-blend": 0.5,
        "atmosphere-blend": [
          "interpolate",
          ["linear"],
          ["zoom"],
          0,
          1,
          10,
          1,
          12,
          0
        ]
      });

      function addFlight(id, dataUrl, color, modelUrl, modelScale) {
        map.addSource(id + '-source', { type: 'geojson', data: dataUrl });
        map.on('data', function (e) {
          if (e.sourceId === id + '-source' && e.sourceDataType === 'metadata') {
            // Add the track log.
            map.addLayer({
              id: id + '-layer',
              type: 'line',
              source: id + '-source',
              layout: { 'line-join': 'round', 'line-cap': 'round' },
              paint: { 'line-color': color, 'line-width': 4 }
            });
            fetch(dataUrl)
              .then(response => response.json())
              .then(geojson => {
                const flightType = geojson.properties.type;
                const tail = geojson.properties.tail;
                const flightName = geojson.properties.flight;
                console.log(`Flight ${flightName} (${flightType}) with tail #${tail} loaded.`);
                const trackArray = parseGeojsonToTrack(geojson);
                const modelTransform = {
                  translateX: 0, translateY: 0, translateZ: 0,
                  rotateX: 0, rotateY: 0, rotateZ: 0,
                  scale: 1
                };
                flightsData[id] = {
                  track: trackArray,
                  color: color,
                  flightType: flightType,
                  flightName: flightName,
                  tail: tail,
                  modelTransform: modelTransform,
                  layerId: id + '-model',
                  scale: modelScale
                };
                const initialCoord = trackArray.length ? trackArray[0].coord : [0, 0];

                // Create the icon marker.
                const iconContainer = document.createElement('div');
                iconContainer.className = 'flight-marker-container';
                const iconElement = document.createElement('div');
                iconElement.className = 'flight-marker-icon';
                iconElement.style.backgroundImage = `url("${createFlightMarkerSVG(color)}")`;
                iconContainer.appendChild(iconElement);
                const iconMarker = new maplibregl.Marker({
                  element: iconContainer,
                  rotationAlignment: 'map'
                })
                  .setLngLat(initialCoord)
                  .addTo(map);
                flightsData[id].iconMarker = iconMarker;
                flightsData[id].iconElement = iconElement;

                // Create the label marker (separate from the icon).
                const labelElement = document.createElement('div');
                labelElement.className = 'flight-marker-label';
                labelElement.innerText = `${flightName} / ${tail} @ 0 m`;
                const labelMarker = new maplibregl.Marker({
                  element: labelElement,
                  rotationAlignment: 'viewport',
                  anchor: 'top-left', // This sets the origin of the marker element to its top-left corner.
                  offset: [20, 0]
                })
                  .setLngLat(initialCoord)
                  .addTo(map);
                flightsData[id].labelMarker = labelMarker;
                flightsData[id].labelElement = labelElement;

                addStlModel(id, modelUrl, color);
              });
          }
        });
      }

      // Add your flights.
      addFlight('AE313D', './assets/AE313D-track.geojson', '#00ff00', './assets/UH-60.stl', 1/1200);
      addFlight('N709PS', './assets/N709PS-track.geojson', '#ff0000', './assets/CRJ7.stl', 1/300);
    });
  </script>
</body>
</html>
